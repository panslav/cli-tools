#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(CDPATH= cd -- "$(dirname -- "$0")" && pwd -P)"
SESS_DIR="${CODEX_SESSIONS_DIR:-$HOME/.codex/sessions}"
LABELS_FILE="${CODEX_SESSION_LABELS_FILE:-$HOME/.local/state/codex-session/labels.tsv}"
SUMMARIES_FILE="${CODEX_SESSION_SUMMARIES_FILE:-$HOME/.local/state/codex-session/summaries.tsv}"
DEFAULT_VAULT_DIR="/Users/evgeny/Library/CloudStorage/OneDrive-Personal/Documents/Рабочее/Obsidian-pro/Professional Vault"
VAULT_DIR="${CODEX_SESSION_VAULT_DIR:-$DEFAULT_VAULT_DIR}"
VAULT_CODEX_SESSION_DIR="${CODEX_SESSION_VAULT_NOTE_DIR:-$VAULT_DIR/Projects/AI/Codex/codex-session}"
SESSIONS_LOG_FILE="${CODEX_SESSION_LOG_FILE:-$VAULT_CODEX_SESSION_DIR/Sessions.md}"
SESSION_CONTEXT_INDEX_FILE="${CODEX_SESSION_CONTEXT_INDEX_FILE:-$VAULT_CODEX_SESSION_DIR/session-context-index.md}"
SESSION_CONTEXTS_DIR="${CODEX_SESSION_CONTEXTS_DIR:-$VAULT_CODEX_SESSION_DIR/session-contexts}"
LEGACY_SESSION_CONTEXT_FILE="${CODEX_SESSION_LEGACY_CONTEXT_FILE:-$VAULT_DIR/Projects/AI/Codex/Session Context.md}"
MODE_LATEST=0
SET_NAME=""
SET_SUMMARY=""
MODE_DELETE=0
SESSION_ID_ARG=""
FILTER=""
LAST_SUMMARY_TRUNCATED=0

usage() {
  cat <<'EOF'
Usage:
  codex-session [--latest] [--id SESSION_ID] [FILTER]
  codex-session --name "Session Name" [--latest|--id SESSION_ID|FILTER]
  codex-session --summary "Up to ten words" [--latest|--id SESSION_ID|FILTER]
  codex-session --delete [--latest|--id SESSION_ID|FILTER]
  codex-session --name "Session Name" --summary "Up to ten words" [target]

Options:
  --latest              Target the most recent session.
  --id SESSION_ID       Target a specific session id.
  --name "TEXT"         Save/update a human-friendly name for the target session.
  --summary "TEXT"      Save/update a summary (stored as first 10 words).
  --delete              Delete the target session and any saved metadata for it.
  -h, --help            Show README.md in the terminal.
EOF
}

show_readme() {
  readme_file="$SCRIPT_DIR/README.md"
  if [ -f "$readme_file" ]; then
    cat "$readme_file"
    return 0
  fi
  echo "README.md not found next to script: $readme_file" >&2
  usage
  return 1
}

normalize_log_field() {
  printf '%s' "${1-}" | tr '\t\r\n' '   ' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//'
}

ensure_session_context_index() {
  mkdir -p "$SESSION_CONTEXTS_DIR" "$(dirname "$SESSION_CONTEXT_INDEX_FILE")"

  if [ ! -f "$SESSION_CONTEXT_INDEX_FILE" ] && [ -f "$LEGACY_SESSION_CONTEXT_FILE" ]; then
    mv "$LEGACY_SESSION_CONTEXT_FILE" "$SESSION_CONTEXT_INDEX_FILE"
  fi

  if [ ! -f "$SESSION_CONTEXT_INDEX_FILE" ]; then
    cat > "$SESSION_CONTEXT_INDEX_FILE" <<'EOF'
# Session Context Index

## Session Context Notes
EOF
  fi

  if ! grep -Fqx "## Session Context Notes" "$SESSION_CONTEXT_INDEX_FILE"; then
    printf '\n## Session Context Notes\n' >> "$SESSION_CONTEXT_INDEX_FILE"
  fi
}

upsert_session_context_link() {
  sid="$1"
  name="$2"
  description="$3"
  ensure_session_context_index

  normalized_name="$(normalize_log_field "$name")"
  normalized_description="$(normalize_log_field "$description")"
  if [ -z "$normalized_name" ]; then
    normalized_name="Unnamed"
  fi
  if [ -z "$normalized_description" ]; then
    normalized_description="No description"
  fi

  rel_note_path="session-contexts/${sid}.md"
  if grep -Fq "[[${rel_note_path}" "$SESSION_CONTEXT_INDEX_FILE"; then
    return 0
  fi

  entry="* [[${rel_note_path}|${normalized_name}]] - ${normalized_description}"
  tmp_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-context-index.XXXXXX")"
  awk -v heading="## Session Context Notes" -v entry="$entry" '
    BEGIN { inserted = 0 }
    {
      print
      if ($0 == heading && inserted == 0) {
        print entry
        inserted = 1
      }
    }
    END {
      if (inserted == 0) {
        print ""
        print heading
        print entry
      }
    }
  ' "$SESSION_CONTEXT_INDEX_FILE" > "$tmp_file"
  mv "$tmp_file" "$SESSION_CONTEXT_INDEX_FILE"
}

append_session_context_entry() {
  sid="$1"
  name="$2"
  description="$3"
  resume_target="$4"
  ensure_session_context_index

  note_path="$SESSION_CONTEXTS_DIR/${sid}.md"
  [ -f "$note_path" ] || : > "$note_path"

  normalized_name="$(normalize_log_field "$name")"
  normalized_description="$(normalize_log_field "$description")"
  if [ -z "$normalized_name" ]; then
    normalized_name="Unnamed"
  fi
  if [ -z "$normalized_description" ]; then
    normalized_description="No description"
  fi

  timestamp="$(date '+%Y-%m-%d %H:%M:%S %Z')"
  {
    if [ -s "$note_path" ]; then
      printf '\n'
    fi
    printf '# %s\n' "$timestamp"
    printf 'Session ID: %s\n\n' "$sid"
    printf '## Summary\n'
    printf '* Name: %s\n' "$normalized_name"
    printf '* Description: %s\n\n' "$normalized_description"
    printf '## Session Context\n'
    printf '* Resume Target: `%s`\n' "$resume_target"
    printf '* Vault: `%s`\n' "$VAULT_DIR"
  } >> "$note_path"

  upsert_session_context_link "$sid" "$normalized_name" "$normalized_description"
}

normalize_sessions_log_file() {
  if [ ! -f "$SESSIONS_LOG_FILE" ]; then
    return 0
  fi

  tmp_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-log-normalize.XXXXXX")"
  awk '
    /^# Sessions[[:space:]]*$/ { next }
    /^## [0-9]{4}-[0-9]{2}-[0-9]{2}[[:space:]]*$/ {
      sub(/^## /, "# ")
      print
      next
    }
    { print }
  ' "$SESSIONS_LOG_FILE" > "$tmp_file"

  trimmed_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-log-trim.XXXXXX")"
  sed -E '/./,$!d' "$tmp_file" > "$trimmed_file"
  mv "$trimmed_file" "$SESSIONS_LOG_FILE"
  rm -f "$tmp_file"
}

mark_latest_log_status_failed() {
  if [ ! -f "$SESSIONS_LOG_FILE" ]; then
    return 0
  fi

  tmp_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-log-failmark.XXXXXX")"
  awk '
    BEGIN { top_header_seen = 0; updated = 0 }
    /^# / && top_header_seen == 0 {
      top_header_seen = 1
      print
      next
    }
    top_header_seen == 1 && updated == 0 && /^\+ / {
      sub(/^\+ /, "X ")
      updated = 1
      print
      next
    }
    { print }
  ' "$SESSIONS_LOG_FILE" > "$tmp_file"
  mv "$tmp_file" "$SESSIONS_LOG_FILE"
}

append_session_log() {
  status="${1-}"
  name="${2-}"
  description="${3-}"
  log_date="$(date '+%Y-%m-%d')"
  log_time="$(date '+%H:%M:%S')"
  log_header="# $log_date"
  normalized_name="$(normalize_log_field "$name")"
  normalized_description="$(normalize_log_field "$description")"

  if [ -z "$normalized_name" ]; then
    normalized_name="Unnamed"
  fi
  if [ -z "$normalized_description" ]; then
    normalized_description="No description"
  fi

  mkdir -p "$(dirname "$SESSIONS_LOG_FILE")"
  [ -f "$SESSIONS_LOG_FILE" ] || : > "$SESSIONS_LOG_FILE"
  normalize_sessions_log_file

  target_section_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-log-target.XXXXXX")"
  rest_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-log-rest.XXXXXX")"
  out_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-log-out.XXXXXX")"

  awk -v hdr="$log_header" '
    $0 == hdr { in_target = 1; next }
    /^# / && in_target == 1 { exit }
    in_target == 1 { print }
  ' "$SESSIONS_LOG_FILE" > "$target_section_file"

  awk -v hdr="$log_header" '
    $0 == hdr { skip_target = 1; next }
    /^# / && skip_target == 1 { skip_target = 0 }
    skip_target == 0 { print }
  ' "$SESSIONS_LOG_FILE" > "$rest_file"

  rest_trimmed_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-log-rest-trim.XXXXXX")"
  sed -E '/./,$!d' "$rest_file" > "$rest_trimmed_file"
  mv "$rest_trimmed_file" "$rest_file"

  {
    printf '%s\n' "$log_header"
    printf '%s %s %s %s %s.\n' "$status" "$log_date" "$log_time" "$normalized_name" "$normalized_description"
    if [ -s "$target_section_file" ]; then
      cat "$target_section_file"
    fi
    if [ -s "$rest_file" ]; then
      printf '\n'
      cat "$rest_file"
    fi
  } > "$out_file"

  mv "$out_file" "$SESSIONS_LOG_FILE"
  rm -f "$target_section_file" "$rest_file"
}

run_codex_resume() {
  if [ "${CODEX_SESSION_DISABLE_VAULT:-0}" = "1" ]; then
    codex resume "$@"
    return $?
  fi

  if [ -d "$VAULT_DIR" ]; then
    (
      cd "$VAULT_DIR"
      codex resume "$@"
    )
    return $?
  fi

  echo "Warning: configured vault path not found: $VAULT_DIR" >&2
  codex resume "$@"
}

resume_codex_with_log() {
  session_id="${1-}"
  resume_name="${2-}"
  resume_description="${3-}"
  resume_target="${4-}"
  shift 4

  append_session_context_entry "$session_id" "$resume_name" "$resume_description" "$resume_target" || true
  append_session_log "+" "$resume_name" "$resume_description" || true
  if run_codex_resume "$@"; then
    return 0
  fi
  rc=$?
  mark_latest_log_status_failed || true
  return "$rc"
}

while [ "$#" -gt 0 ]; do
  case "$1" in
    --latest)
      MODE_LATEST=1
      ;;
    --name)
      shift
      if [ "$#" -eq 0 ]; then
        echo "Missing value for --name" >&2
        exit 1
      fi
      SET_NAME="$1"
      ;;
    --summary)
      shift
      if [ "$#" -eq 0 ]; then
        echo "Missing value for --summary" >&2
        exit 1
      fi
      SET_SUMMARY="$1"
      ;;
    --delete)
      MODE_DELETE=1
      ;;
    --id)
      shift
      if [ "$#" -eq 0 ]; then
        echo "Missing value for --id" >&2
        exit 1
      fi
      SESSION_ID_ARG="$1"
      ;;
    -h|--help)
      show_readme
      exit 0
      ;;
    -*)
      echo "Unknown option: $1" >&2
      exit 1
      ;;
    *)
      if [ -n "$FILTER" ]; then
        echo "Only one FILTER argument is supported." >&2
        exit 1
      fi
      FILTER="$1"
      ;;
  esac
  shift
done

if [ "$MODE_DELETE" -eq 1 ] && { [ -n "$SET_NAME" ] || [ -n "$SET_SUMMARY" ]; }; then
  echo "--delete cannot be combined with --name or --summary." >&2
  exit 1
fi

if [ ! -d "$SESS_DIR" ]; then
  echo "Session directory not found: $SESS_DIR" >&2
  exit 1
fi

format_label() {
  file="$1"
  base="$(basename "$file" .jsonl)"
  label="$(printf '%s\n' "$base" | sed -E "s/^rollout-([0-9]{4}-[0-9]{2}-[0-9]{2})T([0-9]{2})-([0-9]{2})-([0-9]{2}).*$/\1 \2:\3:\4/")"
  if [ "$label" = "$base" ]; then
    date_part="$(printf '%s\n' "$file" | sed -nE 's#^.*/([0-9]{4})/([0-9]{2})/([0-9]{2})/.*$#\1-\2-\3#p')"
    if [ -n "$date_part" ]; then
      label="$date_part 00:00:00"
    fi
  fi
  printf '%s\n' "$label"
}

extract_session_id() {
  file="$1"
  id="$(sed -nE 's/.*"type":"session_meta".*"id":"([^"]+)".*/\1/p' "$file" | head -n 1)"
  if [ -z "$id" ]; then
    id="$(sed -nE 's/.*"id":"([^"]+)".*/\1/p' "$file" | head -n 1)"
  fi
  printf '%s\n' "$id"
}

normalize_name() {
  printf '%s' "$1" | tr '\t\r\n' '   ' | sed -E 's/[[:space:]]+/ /g; s/^ //; s/ $//'
}

sanitize_summary() {
  cleaned="$(printf '%s' "$1" | tr '\t\r\n' '   ' | sed -E 's/[^[:alnum:] ]+/ /g; s/[[:space:]]+/ /g; s/^ //; s/ $//')"
  printf '%s\n' "$cleaned"
}

normalize_summary() {
  cleaned="$(sanitize_summary "$1")"
  printf '%s\n' "$cleaned" | awk '{
    for (i = 1; i <= NF && i <= 10; i++) {
      printf "%s%s", (i == 1 ? "" : " "), $i
    }
    if (NF > 0) { printf "\n" }
  }'
}

name_for_id() {
  sid="$1"
  if [ ! -f "$LABELS_FILE" ]; then
    return 0
  fi
  line="$(grep -F "${sid}"$'\t' "$LABELS_FILE" 2>/dev/null | tail -n 1 || true)"
  if [ -n "$line" ]; then
    printf '%s\n' "${line#*$'\t'}"
  fi
}

summary_for_id() {
  sid="$1"
  if [ ! -f "$SUMMARIES_FILE" ]; then
    return 0
  fi
  line="$(grep -F "${sid}"$'\t' "$SUMMARIES_FILE" 2>/dev/null | tail -n 1 || true)"
  if [ -n "$line" ]; then
    printf '%s\n' "${line#*$'\t'}"
  fi
}

save_name_for_id() {
  sid="$1"
  raw_name="$2"
  cleaned="$(normalize_name "$raw_name")"
  if [ -z "$cleaned" ]; then
    echo "Name cannot be empty." >&2
    exit 1
  fi

  labels_dir="$(dirname "$LABELS_FILE")"
  mkdir -p "$labels_dir"
  tmp_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-labels.XXXXXX")"
  if [ -f "$LABELS_FILE" ]; then
    awk -F '\t' -v sid="$sid" '$1 != sid' "$LABELS_FILE" > "$tmp_file"
  fi
  printf '%s\t%s\n' "$sid" "$cleaned" >> "$tmp_file"
  mv "$tmp_file" "$LABELS_FILE"
}

save_summary_for_id() {
  sid="$1"
  raw_summary="$2"
  sanitized="$(sanitize_summary "$raw_summary")"
  words="$(printf '%s\n' "$sanitized" | awk '{print NF}')"
  cleaned="$(normalize_summary "$raw_summary")"
  if [ -z "$cleaned" ]; then
    echo "Summary cannot be empty." >&2
    exit 1
  fi
  LAST_SUMMARY_TRUNCATED=0
  if [ "${words:-0}" -gt 10 ]; then
    LAST_SUMMARY_TRUNCATED=1
  fi

  summaries_dir="$(dirname "$SUMMARIES_FILE")"
  mkdir -p "$summaries_dir"
  tmp_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-summaries.XXXXXX")"
  if [ -f "$SUMMARIES_FILE" ]; then
    awk -F '\t' -v sid="$sid" '$1 != sid' "$SUMMARIES_FILE" > "$tmp_file"
  fi
  printf '%s\t%s\n' "$sid" "$cleaned" >> "$tmp_file"
  mv "$tmp_file" "$SUMMARIES_FILE"
}

remove_metadata_for_id() {
  sid="$1"
  for target_file in "$LABELS_FILE" "$SUMMARIES_FILE"; do
    if [ ! -f "$target_file" ]; then
      continue
    fi
    tmp_file="$(mktemp "${TMPDIR:-/tmp}/codex-session-meta.XXXXXX")"
    awk -F '\t' -v sid="$sid" '$1 != sid' "$target_file" > "$tmp_file"
    mv "$tmp_file" "$target_file"
  done
}

delete_session_by_idx() {
  target_idx="$1"
  target_number=$((target_idx + 1))
  target_id="${IDS[$target_idx]}"
  target_file="${SESSION_FILES[$target_idx]}"

  if [ -t 0 ] && [ -t 1 ]; then
    printf 'Delete session #%s? [y/N]: ' "$target_number"
    read -r confirm
    case "$(printf '%s' "$confirm" | tr '[:upper:]' '[:lower:]')" in
      y|yes) ;;
      *)
        echo "Delete cancelled."
        return 1
        ;;
    esac
  fi

  case "$target_file" in
    "$SESS_DIR"/*) ;;
    *)
      echo "Refusing to delete file outside session directory: $target_file" >&2
      exit 1
      ;;
  esac

  if [ ! -f "$target_file" ]; then
    echo "Session file not found: $target_file" >&2
    exit 1
  fi

  rm -f "$target_file"
  remove_metadata_for_id "$target_id"

  cleanup_dir="$(dirname "$target_file")"
  while [ "$cleanup_dir" != "$SESS_DIR" ]; do
    rmdir "$cleanup_dir" 2>/dev/null || break
    cleanup_dir="$(dirname "$cleanup_dir")"
  done

  printf 'Deleted session #%s\n' "$target_number"
  return 0
}

edit_session_by_idx() {
  target_idx="$1"
  target_number=$((target_idx + 1))
  edit_kind="$2"
  preset_value="${3-}"
  target_id="${IDS[$target_idx]}"

  case "$edit_kind" in
    name)
      if [ -n "$preset_value" ]; then
        new_name="$preset_value"
      else
        printf 'Enter new name for session #%s: ' "$target_number"
        read -r new_name
      fi
      save_name_for_id "$target_id" "$new_name"
      printf 'Saved session name for #%s -> %s\n' "$target_number" "$(normalize_name "$new_name")"
      ;;
    summary)
      if [ -n "$preset_value" ]; then
        new_summary="$preset_value"
      else
        printf 'Enter new summary for session #%s: ' "$target_number"
        read -r new_summary
      fi
      save_summary_for_id "$target_id" "$new_summary"
      if [ "$LAST_SUMMARY_TRUNCATED" -eq 1 ]; then
        printf 'Saved session summary (truncated to 10 words) for #%s -> [%s]\n' "$target_number" "$(normalize_summary "$new_summary")"
      else
        printf 'Saved session summary for #%s -> [%s]\n' "$target_number" "$(normalize_summary "$new_summary")"
      fi
      ;;
    *)
      echo "Unknown edit type: $edit_kind" >&2
      exit 1
      ;;
  esac
}

select_target_idx() {
  action="$1"
  if [ "$MODE_LATEST" -eq 1 ] || [ "${#IDS[@]}" -eq 1 ]; then
    printf '0\n'
    return 0
  fi

  if command -v fzf >/dev/null 2>&1 && [ -t 0 ] && [ -t 1 ]; then
    OPTIONS=()
    i=0
    while [ "$i" -lt "${#IDS[@]}" ]; do
      OPTIONS+=("${DISPLAYS[$i]}	${IDS[$i]}")
      i=$((i + 1))
    done
    selected_line="$(printf '%s\n' "${OPTIONS[@]}" | fzf --prompt="$action session> " --height=40% --reverse --delimiter=$'\t' --with-nth=1)"
    [ -n "$selected_line" ] || exit 0
    selected_id="${selected_line#*$'\t'}"
    target_idx=0
    for sid in "${IDS[@]}"; do
      if [ "$sid" = "$selected_id" ]; then
        break
      fi
      target_idx=$((target_idx + 1))
    done
    printf '%s\n' "$target_idx"
    return 0
  fi

  i=1
  for label in "${DISPLAYS[@]}"; do
    printf '%2d) %s\n' "$i" "$label"
    i=$((i + 1))
  done
  printf ' 0) Exit\n'
  printf 'Select session number to %s: ' "$action"
  read -r idx
  case "$idx" in
    ''|*[!0-9]*)
      echo "Invalid number." >&2
      exit 1
      ;;
  esac
  if [ "$idx" -eq 0 ]; then
    exit 0
  fi
  if [ "$idx" -lt 1 ] || [ "$idx" -gt "${#IDS[@]}" ]; then
    echo "Selection out of range." >&2
    exit 1
  fi
  printf '%s\n' "$((idx - 1))"
}

auto_summary_for_file() {
  file="$1"
  fallback_name="$2"
  raw="$(sed -nE 's/.*"type":"user_message","message":"([^"]*)".*/\1/p' "$file" | tail -n 1)"
  summary="$(normalize_summary "$raw")"
  if [ -z "$summary" ] && [ -n "$fallback_name" ]; then
    summary="$(normalize_summary "$fallback_name")"
  fi
  if [ -z "$summary" ]; then
    summary="Summary unavailable for this session"
  fi
  printf '%s\n' "$summary"
}

load_sessions() {
  FILES=()
  while IFS= read -r file; do
    FILES+=("$file")
  done < <(find "$SESS_DIR" -type f -name '*.jsonl' | sort -r)

  if [ "${#FILES[@]}" -eq 0 ]; then
    echo "No sessions found." >&2
    return 1
  fi

  IDS=()
  DISPLAYS=()
  SESSION_FILES=()
  SESSION_NAMES=()
  SESSION_SUMMARIES=()
  for file in "${FILES[@]}"; do
    sid="$(extract_session_id "$file")"
    if [ -z "$sid" ]; then
      continue
    fi

    if [ -n "$SESSION_ID_ARG" ] && [ "$sid" != "$SESSION_ID_ARG" ]; then
      continue
    fi

    dt="$(format_label "$file")"
    saved_name="$(name_for_id "$sid")"
    name_text="$saved_name"
    if [ -z "$name_text" ]; then
      name_text="Unnamed"
    fi
    saved_summary="$(summary_for_id "$sid")"
    if [ -n "$saved_summary" ]; then
      summary_text="$(normalize_summary "$saved_summary")"
    else
      summary_text="$(auto_summary_for_file "$file" "$saved_name")"
    fi
    if [ -z "$summary_text" ]; then
      summary_text="Summary unavailable for this session"
    fi
    display="$dt   $name_text [$summary_text]"

    if [ -n "$FILTER" ]; then
      FILTER_LC="$(printf '%s' "$FILTER" | tr '[:upper:]' '[:lower:]')"
      searchable="$(printf '%s %s %s %s %s' "$file" "$sid" "$dt" "$saved_name" "$summary_text" | tr '[:upper:]' '[:lower:]')"
      if ! printf '%s' "$searchable" | grep -Fq "$FILTER_LC"; then
        continue
      fi
    fi

    IDS+=("$sid")
    DISPLAYS+=("$display")
    SESSION_FILES+=("$file")
    SESSION_NAMES+=("$name_text")
    SESSION_SUMMARIES+=("$summary_text")
  done

  if [ "${#IDS[@]}" -eq 0 ]; then
    if [ -n "$SESSION_ID_ARG" ]; then
      echo "No matching session found for id: $SESSION_ID_ARG" >&2
    else
      echo "No matching sessions found." >&2
    fi
    return 1
  fi
}

load_sessions || exit 1

if [ -n "$SET_NAME" ] || [ -n "$SET_SUMMARY" ]; then
  target_idx="$(select_target_idx "update")"
  target_number=$((target_idx + 1))
  if [ -n "$SET_NAME" ]; then
    save_name_for_id "${IDS[$target_idx]}" "$SET_NAME"
    printf 'Saved session name for #%s -> %s\n' "$target_number" "$(normalize_name "$SET_NAME")"
  fi
  if [ -n "$SET_SUMMARY" ]; then
    save_summary_for_id "${IDS[$target_idx]}" "$SET_SUMMARY"
    if [ "$LAST_SUMMARY_TRUNCATED" -eq 1 ]; then
      printf 'Saved session summary (truncated to 10 words) for #%s -> [%s]\n' "$target_number" "$(normalize_summary "$SET_SUMMARY")"
    else
      printf 'Saved session summary for #%s -> [%s]\n' "$target_number" "$(normalize_summary "$SET_SUMMARY")"
    fi
  fi
  exit 0
fi

if [ "$MODE_DELETE" -eq 1 ]; then
  target_idx="$(select_target_idx "delete")"
  delete_session_by_idx "$target_idx" || exit 0
  exit 0
fi

if [ "$MODE_LATEST" -eq 1 ] && [ -z "$FILTER" ] && [ -z "$SESSION_ID_ARG" ]; then
  latest_id="${IDS[0]}"
  latest_name="${SESSION_NAMES[0]:-Unnamed}"
  latest_summary="${SESSION_SUMMARIES[0]:-Summary unavailable for this session}"
  resume_codex_with_log "$latest_id" "$latest_name" "$latest_summary" "--last" --last
  exit $?
fi

if command -v fzf >/dev/null 2>&1 && [ -t 0 ] && [ -t 1 ]; then
  OPTIONS=()
  i=0
  while [ "$i" -lt "${#IDS[@]}" ]; do
    OPTIONS+=("${DISPLAYS[$i]}	${IDS[$i]}")
    i=$((i + 1))
  done
  CHOICE="$(printf '%s\n' "${OPTIONS[@]}" | fzf --prompt='codex session> ' --height=40% --reverse --delimiter=$'\t' --with-nth=1)"
  [ -n "$CHOICE" ] || exit 0
  SESSION_ID="${CHOICE#*$'\t'}"
else
  while :; do
    i=1
    for label in "${DISPLAYS[@]}"; do
      printf '%2d) %s\n' "$i" "$label"
      i=$((i + 1))
    done
    printf ' 0) Exit\n'
    printf 'Select session: N=resume, N delete, N name: <text>, N summary: <text>: '
    read -r idx
    idx="$(printf '%s' "$idx" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
    case "$idx" in
      '')
        echo "Invalid number." >&2
        continue
        ;;
    esac

    if [ "$idx" = "0" ]; then
      exit 0
    fi

    if [[ "$idx" =~ ^([0-9]+)[[:space:]]+([Nn][Aa][Mm][Ee]|[Ss][Uu][Mm][Mm][Aa][Rr][Yy]):[[:space:]]*(.*)$ ]]; then
      edit_num="${BASH_REMATCH[1]}"
      edit_cmd="$(printf '%s' "${BASH_REMATCH[2]}" | tr '[:upper:]' '[:lower:]')"
      edit_value="${BASH_REMATCH[3]}"
      if [ "$edit_num" -lt 1 ] || [ "$edit_num" -gt "${#IDS[@]}" ]; then
        echo "Selection out of range." >&2
        continue
      fi
      edit_idx=$((edit_num - 1))
      case "$edit_cmd" in
        name)
          edit_session_by_idx "$edit_idx" "name" "$edit_value" || true
          ;;
        summary)
          edit_session_by_idx "$edit_idx" "summary" "$edit_value" || true
          ;;
      esac
      load_sessions || exit 1
      continue
    fi

    if [[ "$idx" =~ ^([0-9]+)[[:space:]]+[Dd][Ee][Ll][Ee][Tt][Ee]$ ]]; then
      delete_num="${BASH_REMATCH[1]}"
      if [ "$delete_num" -lt 1 ] || [ "$delete_num" -gt "${#IDS[@]}" ]; then
        echo "Selection out of range." >&2
        continue
      fi
      delete_idx=$((delete_num - 1))
      delete_session_by_idx "$delete_idx" || true
      load_sessions || exit 1
      continue
    fi

    if [[ "$idx" =~ ^[0-9]+$ ]]; then
      if [ "$idx" -lt 1 ] || [ "$idx" -gt "${#IDS[@]}" ]; then
        echo "Selection out of range." >&2
        continue
      fi
      SESSION_ID="${IDS[$((idx - 1))]}"
      break
    fi

    echo "Invalid number." >&2
  done
fi

if [ -z "$SESSION_ID" ]; then
  echo "Could not resolve a session id." >&2
  exit 1
fi

selected_idx=0
for sid in "${IDS[@]}"; do
  if [ "$sid" = "$SESSION_ID" ]; then
    break
  fi
  selected_idx=$((selected_idx + 1))
done

selected_name="${SESSION_NAMES[$selected_idx]:-Unnamed}"
selected_summary="${SESSION_SUMMARIES[$selected_idx]:-Summary unavailable for this session}"
resume_codex_with_log "$SESSION_ID" "$selected_name" "$selected_summary" "$SESSION_ID" "$SESSION_ID"
